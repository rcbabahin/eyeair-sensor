// This callback file is created for your convenience. You may add application
// code to this file. If you regenerate this file over a previous version, the
// previous version will be overwritten and any code you have added will be
// lost.

#include "app/framework/include/af.h"
#include "hal/hal.h"
#include EMBER_AF_API_NETWORK_STEERING
#include "app/framework/include/af.h"
#include "app/util/ezsp/ezsp-enum.h"
#include "ccs811.h"
#include "pmsa003.h"
#include "sht20.h"
#include "ws2812.h"
#include "eyeair.h"
#include "buzzer.h"
#include "esp12f.h"

#define BUFFER_SIZE	32
EmberEventControl startScanAndConnectEventControl, PMSAEventControl, SHTEventControl, CCSEventControl, startBuzzerAndRGBEventControl;
uint8_t buffer[BUFFER_SIZE];

void Init_I2C(I2C_TypeDef *i2c)
{
	 // Use default settings
	  I2C_Init_TypeDef i2cInit = I2C_INIT_DEFAULT;

		// Enable oscillator to GPIO and I2C0 modules
	  CMU_ClockEnable(cmuClock_I2C0, true);
	  CMU_ClockEnable(cmuClock_GPIO, true);

	  // Using PA2 (SDA) and PA3 (SCL)
	  GPIO_PinModeSet(gpioPortA, 2, gpioModeWiredAndPullUpFilter, 1);
	  GPIO_PinModeSet(gpioPortA, 3, gpioModeWiredAndPullUpFilter, 1);


	  // Enable pins at location 2 as specified in datasheet
	  i2c->ROUTEPEN = 0;
	  i2c->ROUTELOC0 = (_I2C_ROUTELOC0_SDALOC_LOC2 << _I2C_ROUTELOC0_SDALOC_SHIFT) |
                     (_I2C_ROUTELOC0_SCLLOC_LOC2 << _I2C_ROUTELOC0_SCLLOC_SHIFT);
	  i2c->ROUTEPEN = I2C_ROUTEPEN_SDAPEN | I2C_ROUTEPEN_SCLPEN;
	  // Initializing the I2C
	  I2C_Init(i2c, &i2cInit);
}

void Init_USART(USART_TypeDef *usart)
{
  USART_InitAsync_TypeDef init = USART_INITASYNC_DEFAULT;
  init.baudrate = 9600;

  // Enable oscillator to GPIO and USART0 modules
  CMU_ClockEnable(cmuClock_HFPER, true);
  CMU_ClockEnable(cmuClock_GPIO, true);
  CMU_ClockEnable(cmuClock_USART0, true);

  // set pin modes for UART0 TX and RX pins
  GPIO_PinModeSet(gpioPortA, 1, gpioModeInput, 0);
  GPIO_PinModeSet(gpioPortA, 0, gpioModePushPull, 1);

  // Initialize USART asynchronous mode and route pins
  USART_InitAsync(usart, &init);
  usart->ROUTEPEN |= USART_ROUTEPEN_RXPEN | USART_ROUTEPEN_TXPEN;
  usart->ROUTELOC0 = USART_ROUTELOC0_RXLOC_LOC0 | USART_ROUTELOC0_TXLOC_LOC0;

  USART_InitAsync_TypeDef init1 = USART_INITASYNC_DEFAULT;
  init.baudrate = 115200;

  // Enable oscillator to GPIO and USART0 modules
  CMU_ClockEnable(cmuClock_USART1, true);

  // set pin modes for UART1 TX and RX pins
  GPIO_PinModeSet(gpioPortC, 7, gpioModeInput, 0);
  GPIO_PinModeSet(gpioPortC, 6, gpioModePushPull, 1);

  // Initialize USART asynchronous mode and route pins
  USART_InitAsync(USART1, &init1);
  USART1->ROUTEPEN |= USART_ROUTEPEN_RXPEN | USART_ROUTEPEN_TXPEN;
  USART1->ROUTELOC0 = USART_ROUTELOC0_RXLOC_LOC11 | USART_ROUTELOC0_TXLOC_LOC11;
}

void startBuzzerAndRGBEventHandler(void)
{
  emberEventControlSetActive(startScanAndConnectEventControl);
  emberEventControlSetActive(PMSAEventControl);
  emberEventControlSetActive(SHTEventControl);
  emberEventControlSetActive(CCSEventControl);
	emberEventControlSetInactive(startBuzzerAndRGBEventControl);
}

void PMSAEventHandler(void)
{
	PMSA_RequestRead(EyeAirDevice.pmsa);
	PMSAStateType state = PMSA_Read(EyeAirDevice.pmsa, buffer, BUFFER_SIZE);

	if (state == RECEIVED_SUCCES)
	{
			emberAfWriteServerAttribute(1, ZCL_PM1_0_MFG_SPECIFIC_CLUSTER_ID,
			                            ZCL_ATTRIBUTE_ONE_ATTRIBUTE_ID,
			                            (uint8_t *)&(EyeAirDevice.pmsa->PM1_0_AE),
			                            ZCL_INT16U_ATTRIBUTE_TYPE);
			emberAfWriteServerAttribute(1, ZCL_PM2_5_MFG_SPECIFIC_CLUSTER_ID,
			                            ZCL_ATTRIBUTE_ONE_ATTRIBUTE_ID,
			                            (uint8_t *)&(EyeAirDevice.pmsa->PM2_5_AE),
			                            ZCL_INT16U_ATTRIBUTE_TYPE);
			emberAfWriteServerAttribute(1, ZCL_PM10_0_MFG_SPECIFIC_CLUSTER_ID,
			                            ZCL_ATTRIBUTE_ONE_ATTRIBUTE_ID,
			                            (uint8_t *)&(EyeAirDevice.pmsa->PM10_0_AE),
			                            ZCL_INT16U_ATTRIBUTE_TYPE);


			emberEventControlSetInactive(PMSAEventControl);
			emberEventControlSetDelayMS(PMSAEventControl, 1000);

	}
//	WIFI_Init();
	border_control_PM();

}

void SHTEventHandler(void)
{

	EyeAirDevice.sht->temp = SHT20_GetTemperature(1);
	EyeAirDevice.sht->rh = SHT20_GetRelativeHumidity(1);
	/*
	 *
	 * WRITE cel and rh values to CCS811 sensor
	 *
	 * */
	emberEventControlSetInactive(SHTEventControl);
	emberEventControlSetDelayMS(SHTEventControl, 1000);
}

void CCSEventHandler(void)
{
	CO2_sensor_init(EyeAirDevice.ccs);
	CO2_sensor_get_value(EyeAirDevice.ccs);

	emberAfWriteServerAttribute(1, ZCL_CARBON_DIOXIDE_MFG_SPECIFIC_CLUSTER_ID,
	                            ZCL_ATTRIBUTE_ONE_ATTRIBUTE_ID,
	                            (uint8_t *)&(EyeAirDevice.ccs->co2),
	                            ZCL_INT16U_ATTRIBUTE_TYPE);
	emberAfWriteServerAttribute(1, ZCL_TVOC_MFG_SPECIFIC_CLUSTER_ID,
	                            ZCL_ATTRIBUTE_ONE_ATTRIBUTE_ID,
	                            (uint8_t *)&(EyeAirDevice.ccs->tvoc),
	                            ZCL_INT16U_ATTRIBUTE_TYPE);

	emberEventControlSetInactive(CCSEventControl);
	emberEventControlSetDelayMS(CCSEventControl, 1500);

  border_control_CO2_TVOC();


}

void startScanAndConnectEventHandler(void)
{
  if (emberAfNetworkState() != EMBER_JOINED_NETWORK) {
      emberAfPluginNetworkSteeringStart();
  } else {
      emberEventControlSetInactive(startScanAndConnectEventControl);
  }
}

/** @brief Main Start
 *
 * This function is called at the start of main after the HAL has been
 * initialized.  The standard main function arguments of argc and argv are
 * passed in.  However not all platforms have support for main() function
 * arguments.  Those that do not are passed NULL for argv, therefore argv should
 * be checked for NULL before using it.  If the callback determines that the
 * program must exit, it should return true.  The value returned by main() will
 * be the value written to the returnCode pointer.  Otherwise the callback
 * should return false to let normal execution continue.
 *
 * @param returnCode   Ver.: always
 * @param argc   Ver.: always
 * @param argv   Ver.: always
 */
boolean emberAfMainStartCallback(int* returnCode,
                                 int argc,
                                 char** argv)
{
  // NOTE:  argc and argv may not be supported on all platforms, so argv MUST be
  // checked for NULL before referencing it.  On those platforms without argc 
  // and argv "0" and "NULL" are passed respectively.
	sl_sleeptimer_init();

  Init_I2C(I2C0);
	Init_USART(USART0);
	init_buzzer();
	init_WS2812();
  PMSA_Init(EyeAirDevice.pmsa);
  SHT20_Init(EyeAirDevice.sht);
  CO2_sensor_init(EyeAirDevice.ccs);

  emberEventControlSetActive(startBuzzerAndRGBEventControl);


  return false;  // exit?
}


